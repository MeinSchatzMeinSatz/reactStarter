# 리액트의 렌더링이 일어나는 이유.

1. 최초 렌더링: 사용자가 처음 애플리케이션에 진입하면 당연히 렌더링해야 할 결과물이 필요하다. 리액트는 브라우저에 이 정보를 제공하기 위해 최초 렌더링을 수행한다.

2. [리렌더링]: 리렌더링은 처음 애플리케이션에 진입했을 때 최초 렌더링이 발생한 이후로 발생하는 모든 렌더링을 의미한다.

리렌더링이 발생하는 이유는 다음과 같다. - 클래스 컴포넌트의 setState가 실행되는 경우 -클래스 컴포넌트의 forceUpdate가 실행되는 경우 - 함수 컴포넌트의 useState()의 두 번째 배열 요소인 setter가 실행되는 경우 - 함수 컴포넌트의 useReducer()의 두 번째 배열요소인 dispatch가 실행되는 경우 - 컴포넌트 key props가 변경되는 경우

```javascript
const arr = [1, 2, 3]

export default function App() {
    return (
        <ul>
            {/* 키가 없다면 'Warning: Each child in a list should have a unique "key" prop'이 출력된다. */}
            {arr.map((index) => (
                <li key={index}>{index}</li>
            ))}
    )
}
```

리액트에서 배열에 key를 쓰지 않으면 콘솔에 경고가 출력되기 때문에 key를 유일한 값으로 추가하는 것이 일반적이지만 정작 왜 추가해야 하는지는 모르는 경우가 많다. 왜 key가 필요할까?

리액트에서 key는 리렌더링이 발생하는 동안 형제 요소들 사이에서 동일한 요소를 식별하는 값이다. 앞서 앞서 리액트 파이버 트리 구조를 떠올려보면 해당 트리 구조에서 형제 컴포넌트를 구별하기 위해 sibling 이라는 속성값을 사용했다. 동일한 자식 컴포넌트가 여러 개 있는 구조를 상상해 보자. 리렌더링이 발생하면, current 트리와 workInProgress 트리 사이에서 어떠한 컴포넌트가 변경이 있었는지 구별해야 한다.

이 두 트리 사이에서 같은 컴포넌트인지를 구별하는 값이 바로 key다. 이 변경 사항을 구별하는 작업은 리렌더링이 필요한 컴포넌트를 최소화해야 하므로 반드시 필요한 작업이다.

key가 존재한다면 두 트리 사이에서 동일한 key를 가지고 있는 컴포넌트는 이를 기준으로 구별할 수 있지만, 이 key가 없다면 단순히 파이버 내부의 sibling 인덱스만을 기준으로 판단하게 된다.

```javascript
const Child = memo() => {
    return <li>hello</li>
}

function List({ arr }: {arr: number[]}) {
    const [state, setState] = useState(0)

    function handleButtonClick() {
        setState((prev) => prev + 1)
    }

    return (
        <>
            <button onClick={handleButtonClick}>{state}</button>

            <ul>
                {arr.map((_, index) => (
                    <Child />
                ))}
            </ul>
        </>
    )
}
```

Child에 key가 없어서 경고문이 발생했지만 setState의 호출로 부모 컴포넌트인 List의 리렌더링이 발생해도 Child는 memo로 선언돼 있으므로 리렌더링이 발생하지 않는다.

결국 <Chlid />는 <Child key={index}/>와 동일하게 작동한다.

만약 반대로 <Child key={Math.random()} />과 같이 렌더링할 때마다 변하는 임의의 값을 key에 넣는 다고 가정해보자. 이때는 렌더링이 일어날 때마다 sibling 컴포넌트를 명확히 구분할 수 없으므로 Child는 memo로 선언됐더라도 매번 리렌더링이 일어나게 된다.

즉, key의 변화는 리렌더링을 야기한다.

이러한 특징을 이용하면 key를 활용해 강제로 리렌더링을 일으키는 것이 가능해진다.

props가 변경되는 경우: 부모로부터 전달받는 값인 props가 달라지면 이를 사용하는 자식 컴포넌트에도 변경이 필요하므로 리렌더링이 일어난다.

부모 컴포넌트가 렌더링될 경우: 한 가지 주의할 점은, 부모 컴포넌트가 리렌더링된다면 자식 컴포넌트도 무조건 리렌더링이 일어난다는 것이다.

## 리엑트 렌더링 시나리오

리액트에서 렌더링이 일어나는 경우는 앞에서 이야기한 시나리오뿐이다.

1. 클래스 컴포넌트의 setState가 실행되는 경우 -클래스 컴포넌트의 forceUpdate가 실행되는 경우
2. 함수 컴포넌트의 useState()의 두 번째 배열 요소인 setter가 실행되는 경우
3. 함수 컴포넌트의 useReducer()의 두 번째 배열요소인 dispatch가 실행되는 경우
4. 컴포넌트 key props가 변경되는 경우
5. key의 변화를 이용한 리렌더링
6. props가 변경되는 경우
7. 부모 컴포넌트가 렌더링 될 경우.

이러한 사실을 이해했다면 왜 mobx-react나 react-redux와 같은 리액트 패키지를 설치해야 하는지도 알 수 있게 된다. MobX와 Redux는 라이브러리 어디에선가 각자의 방법으로 상태를 관리해 주지만 이 상태 관리가 리액트의 리렌더링으로 이어지지는 않는다.

그러므로 각각 mobx-react, react-redux가 앞선 라이브러리로부터 변경된 상태를 바탕으로 위에서 언급한 방법 중 하나를 사용해 리렌더링을 발생시키는 것이다.
Recoil 처럼 이러한 별도의 리액트 페키지가 없이도 상태 관리가 되는 라이브러리의 경우에는 내부에서 useState 등으 통해 리렌더링을 발생시킨다. 이 내용은 5.2절 '리액트 훅으로 시작되는 상태 관리'에서 다룬다.

## 리액트의 렌더링 프로세스

지금까지 리액트에서 언제 렌더링이 발생하는지 살펴보았다. 이제 본격적으로 렌더링이 어떤 과정을 거쳐 수정되는지 살펴보자. 렌더링 프로세스가 시작되면 리액트는 컴포넌트의 루트에서부터 차근차근 아래쪽으로 내려가면서 업데이트가 필요하다고 지정돼 있는 모든 컴포넌트를 찾는다. 만약 여기서 업데이트가 필요하다고 지정돼 있는 컴포넌트를 발견하면 클래스 컴포넌트의 경우에는 클래스 내부의 render() 함수를 실행하게 되고, 함수 컴포넌트의 경우에는 FunctionComponent() 그 자체를 호출한 뒤에 그 결과물을 저장한다.

앞서 언급한 바와 같이 일반적으로 렌더링 결과물은 JSX 문법으로 구성돼 있고, 이것이 자바스크립트로 컴파일되면서 React.createElement()를 호출하는 구문으로 변환된다. 여기서 createElement는 브라우저의 UI 구조를 설명할 수 있는 일반적인 자바스크립트 객체를 반환한다. 다음 예제를 살펴보자.

```javascript
function Hello() {
    return (
        <TestComponent a={35} b="yceffort">
            안녕하세요
        </TestComponent>
    );
}
```

위 JSX 문법은 다음과 같은 React.createElement를 호출해서 변환된다.

```javascript
function Hello() {
    return React.createElement(
        TestComponent,
        {a: 35, 'yceffort'},
        '안녕하세요',
    )
}
```

결과물은 다음과 같다.

```javascript
{type: TestComponent, props: {a: 35, b:"yceffort", chilren: "안녕하세요"}}
```

렌더링 프로세스가 실행되면서 이런 과정을 거쳐 각 컴포넌트의 렌더링 결과물을 수집한 다음, 리액트의 새로운 트리인 가상 DOM과 비교해 실제 DOM에 반영하기 위한 모든 변경 사항을 차례차례 수집한다.

이렇게 계산하는 과정을 바로 2.2절 '가상 DOM과 리액트 파이버'에서 다뤘던 리액트의 재조정이라고 한다. 이러한 재조정 과정이 모두 끝나면 모든 변경 사항을 하나의 동기 시퀀스로 DOM에 적용해 변경된 결과물이 보이게 된다.

여기서 한 가지 주목해야 할 것은 리액트의 렌더링은 렌더 단계와 커밋 단계라는 총 두 단계로 분리되어 실행된다는 것이다. 이번에는 렌더 단계와 커밋 단계에서 어떤 일이 벌어지는지 살펴보자.

## 렌더와 커밋

먼저 렌더 단계와 대해 알아보자. 렌더 단계(Render Phase)는 컴포넌트를 렌더링하고 변경 사항을 계산하는 모든 작업을 말한다.

-   렌더 단계: 컴포넌트를 렌더링하고 변경 사항을 게산하는 모든 작업을 말한다.

즉, 렌더링 프로세스에서 컴포넌트를 실행해(render() 또는 return) 이 결과와 이전 가상 DOM을 비교하는 과정을 거쳐 변경이 필요한 컴포넌트를 체크하는 단계다. 여기서 비교하는 것은 크게 세 가지로, type, props, key다. 이 세 가지 중 하나라도 변경된 것이 있으면 변경이 필요한 컴포넌트로 체크해 둔다.

그 다음으로 커밋 단계(Commit Phase)는 렌더 단계의 변경 사항을 실제 DOM에 적용해 사용자에게 보여주는 과정을 말한다.

-   커밋 단계: 렌더 단계의 변경 사항을 실제 DOM에 적용해 사용자에게 보여주는 과정

이 단계가 끝나야 비로소 브라우저의 렌더링이 발생한다.

리액트가 먼저 DOM을 커밋 단게에서 업데이트한다면 이렇게 만들어진 모든 DOM 노드 및 인스턴스를 가리키도록 리액트 내부의 참조를 업데이트한다. 그 다음, 생명주기 개념이 있는 클래스 컴포넌트에서는 componentDidMount, componentDidUpdate 메서드를 호출하고, 함수 컴포넌트에서는 useLayoutEffect 훅을 호출한다.

여기서 알 수 있는 [중요한] 사실은 `리액트의 렌더링이 일어난다고 해서 무조건 DOM 업데이트가 일어나는 것은 아니라는 것이다.` 렌더링을 수행했으나 커밋 단계는 생략될 수 있다. 즉 리액트의 렌더링은 꼭 가시적인 변경이 일어나지 않아도 발생할 수 있다. 렌더링 과정 중 첫 번째 단계인 변경사항을 감지할 수 없다면 커밋 단계가 생략되어 브라우저의 DOM 업데이트가 일어나지 않을 수 있다.

이 두 가지 과정으로 이뤄진 리액트의 렌더링은 항상 동기식으로 작동했다. 따라서 따라서 렌더링 과정이 길어질수록 애플리케이션의 성능 저하로 이어지고, 결과적으로 그 시간만큼 브라우저의 다른 작업을 지연시킬 가능성이 있다.

이는 사실 렌더링 프로세스의 특징을 생각해 보면 당연한 것이다. 렌더링이 순차적인 동기 방식이 아니라 순서가 보장되지 않는 비동기 방식으로 이뤄질 경우 사용자는 하나의 상태에 대해 여러 가지 다른 UI를 보게 될 것이다. A라는 상태가 변경되면 B와 C가 각각 B1, C1이 되어야 하는데, A가 변경됐음에도 하나의 컴포넌트가 뒤늦게 변경되어 B, C1 상태로 남아있다고 가정해 보자. 이는 사용자에게 혼란을 줄 수 있다.

그럼에도 이러한 비동기 렌더링 시나리오는 몇 가지 상황에서 유효할 수도 있다. B의 컴포넌트 렌더링 작업이 무거워 상대적으로 빠르게 렌더링할 수 있는 C라도 변경해서 보여줄 수 있다면? 의도된 우선순위로 컴포넌트를 렌더링해 최적화할 수 있는 비동기 렌더링, 즉, 이른바 동시성 렌더링이 리액트 18에서 도입됐다. 이 동시성 렌더링 중 렌더 단게가 비동기로 작동해 특정 렌더링의 우선순위를 낮추거나, 필요하다면 중단하거나 재시작하거나, 경우에 따라서는 포기할 수도 있다. 이를 통해 브라우저의 동기 작업을 차단하지 않고 백그라운드에서 새로운 리액트 트리를 준비할 수도 있으므로 사용자는 더욱 매끄러운 사용자 경험을 누릴 수 있다. 이에 대한 자세한 내용은 10.2절 '리액트 18 버전 살펴보기'에서 다룬다.

## 일반적인 렌더링 시나리오 살펴보기

지금까지 리액트의 렌더링이 어떠한 과정을 거쳐 실행되는지 살펴봤다. 지금까지 언급한 내용을 바탕으로 예제 리액트 코드를 살펴보면서 리액트의 렌더링이 어떻게 일어나는지 살펴보자.

```javascript
import { useState } from "react";

export default function A() {
    return (
        <div className="App">
            <h1>Hello React!</h1>
            <B />
        </div>
    );
}

function B() {
    const [counter, setCounter] = useState(0);

    function handleButtonClick() {
        setCounter((previous) => previous + 1);
    }

    return (
        <>
            <label>
                <C number={counter} />
            </label>
            <button onClick={handleButtonClick}>+</button>
        </>
    );

    function C({ number }) {
        return (
            <div>
                {number} <D />
            </div>
        );
    }
}

function D() {
    return <>리액트 재밌다!</>;
}
```

예제 코드에는 A, B, C, D라는 이름을 가진 총 4개의 컴포넌트가 있으며, 순서에 따라 부모와 자식 관계를 가지고 있는 일반적인 리액트 웹 어플리케이션의 모습을 띠고 있다. 그리고 사용자가 B 컴포넌트의 버튼을 눌러 counter 변수를 업데이트한다고 가정해 보자. 그 순간 리액트에서는 다음과 같은 순서로 렌더링이 일어난다.

1. B 컴포넌트의 setState가 호출된다.
2. B 컴포넌트의 리렌더링 작업이 렌더링 큐에 들어간다.
3. 리액트는 트리 최상단에서부터 최상단에서부터 렌더링 경로를 검사한다.
4. A 컴포넌트는 리렌더링이 필요한 컴포넌트로 표시돼 있지 않으므로 별다른 작업을 하지 않는다.
5. 그 다음 하위 컴포넌트인 B 컴포넌트로 표시돼 있지 않으므로 별다른 작업을 하지 않는다.
6. 5번 과정에서 B는 C를 반환했다.
7. C는 props인 number가 업데이트됐다. 그러므로 업데이트가 필요한 컴포넌트로 체크돼 있고 업데이트한다.
8. 7번 과정에서 C는 D를 반환했다.
9. D도 마찬가지로 업데이트가 필요한 컴포넌트로 체크되지 않았다. 그러나 C가 렌더링 됐으므로 그 자식인 D도 렌더링됐다.

즉, 컴포넌트를 렌더링하는 작업은 별도로 렌더링을 피하기 위한 조치가 돼 있지 않은 한 하위 모든 컴포넌트에 영향을 미친다. 그리고 부모가 변경됐다면 Prop가 변경됐는지와 상관없이 무조건 자식 컴포넌트도 리렌더링된다.

상위 컴포넌트, 특히 루트에서 무언가 렌더링을 발생시키는 작업이 일어난다는 것은 하위 모든 컴포넌트의 리렌더링을 트리거한다는 뜻이다. 설계에 따라 다르겠지만 설령 이 작업이 하위 컴포넌트에 변경 사항을 야기하지 않더라도 리액트는 이와 상관없이 어쨌든 리렌더링 작업을 요청하고 비교 작업을 수행하므로 그만큼의 시간과 노력이 소요된다.

만약 D 컴포넌트에 memo를 추가하면 어떻게 될까?

```javascript
// ...

const D = memo(() => {
    return <>리액트 재밌다!</>;
});
```

동일하게 B 컴포넌트에서 상태값이 변경됐음에도 memo로 래핑돼 있어 렌더링이 일어나지 않았음을 알 수 있다. 리액트의 렌더링 단게에 기초해 정확하게 이야기한다면 렌더 단계에서 컴포넌트 비교를 거쳤지만 memo로 서언한 덕분에 props가 변경되지 않으면 렌더링이 생략되므로 커밋 단계도 생략된 것이다.

## 정리

지금까지 리액트에서 렌더링이 언제 어떻게 일어나는지, 또 렌더링이 어떤 과정을 거쳐서 브라우저의 결과물에 영향을 미치는지 살펴보았다.

리액트 애플리케이션을 만들어 본 경험이 있다 하더라도 리액트의 리렌더링 과정을 개발자 스스로가 주의 깊게 살펴보지 않았다면 꽤나 자주 렌더링이 일어난다는 사실을 눈치채지 못했을 것이다. 이번 기회를 토대로 state나 props 등의 변화가 리액트 애플리케이션 전반에 어떠한 영향을 미치는지 주의 깊게 살펴보길 바란다. 리액트에서 일어나는 렌더링 시나리오를 정확히 이해한다면 컴포넌트의 트리 구조를 개선하거나 불필요한 렌더링 횟수를 줄임으로써 성능 좋은 리액트 웹 어플리케이션을 만드는 데 많은 도움이 된다.
