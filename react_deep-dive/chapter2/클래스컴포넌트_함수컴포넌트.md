# 클래스 컴포넌트와 함수 컴포넌트

많은 사람들이 함수 컴포넌트는 꽤 최근에 생겼다고 오해하지만 사실 함수 컴포넌트는 리액트 0.14 버전부터 만들어진 꽤 역사가 깊은 컴포넌트 선언 방식이다. 0.14 버전에서 함수 컴포넌트가 소개됐을 때는 stateless functional component, 이른바 무상태 함수 컴포넌트라고 해서 별도의 상태 없이 단순히 어떠한 요소를 정적으로 렌더링하는 것이 목적이었다. 다음 예제는 실제 0.14 버전에서 함수 컴포넌트를 소개한 코드다.

```javascript
var Aquarium = (props) => {
    var fish = getFish(props.species);
    return <Tank>{fiush}</Tank>;
};

var Aquarium = ({ species }) => <Tank>{getFish(species)}</Tank>;
```

즉, 이때 당시 함수 컴포넌트는 클새스 컴포넌트에서 별다른 생명주기 메서드나 상태(this.states)가 필요없이 render만 하는 경우에만 제한적으로 사용됐다. 함수 컴포넌트가 각광받기 시작한 것은 16.8 버전에서 훅이 소개된 이후였다.

함수 컴포넌트에 훅이 등장한 이후 함수 컴포넌트에서 상태나 생명주기 메서드 비슷한 작업을 흉내 낼 수 있게 되자 상대적으로 보일러플레이트가 복잡한 클래스 컴포넌트보다 함수 컴포넌트를 더 많이 쓰기 시작했다. 그러한 과도기에 많은 혼란이 발생했다. 함수 컴포넌트에서는 생명주기 메서드를 어떻게 써야 할까? 기존에 클래스 컴포넌트로 작성돼 있던 코드는 모두 함수 컴포넌트로 변경해야 할까? 클래스 컴포넌트는 언젠가 지원 중단(deprecated)되는 것일까? 클래스 컴포넌트는 이제 몰라도 되는 걸까?

클래스 컴포넌트와 함수 컴포넌트의 차이는 무엇인지, 그리고 각각의 컴포넌트를 작성할 때 고려해야 할 것이 무엇인지 등에 대해서 다뤄보려고 한다.

이번 장에서 다룬 내용은 본격적으로 리액트 코드를 작성하기에 앞서 과거 클래스 컴포넌트에 대한 이해를 넓히거나 혹은 기존 리액트 코드를 리팩터링하고 유지보수하는 데 많은 도움이 될 것이다.

## 클래스 컴포넌트

이미 대부분의 리액트 개발자들이 클래스 컴포넌트를 기억에서 지웠겠지만 기존 리액트 16.8 미만으로 작성된 코드에는 클래스 컴포넌트가 대다수일 것이다. 이런 오래된 코드의 유지보수 내지는 오래전에 개발된 라이브러리 등을 사용할 때 도움을 얻기 위해서는 클래스 컴포넌트의 구조를 이해할 필요가 있다.

```javascript
import React from "react";

class SampleComponent extends React.Component {
    render() {
        return <h2>Sample Component</h2>;
    }
}
```

기본적으로 클래스 컴포넌트를 만드려면 클래스를 선언하고 extends로 만들고 싶은 컴포넌트를 extends해야 한다. extends구문에 넣을 수 있는 클래스는 다음과 같다.

-   React.Component
-   React.PureComponent
    이 둘의 차이점은 잠시 후 소개할 클래스 컴포넌트인 shouldComponentUpdate를 다루는 데 있다. 이는 잠시 후에 소개하도록 한다.

컴포넌트를 만들 때 주로 쓰이는 props, state, 그리고 메서드는 다음과 같이 정의한다.

```javascript
import React from 'react'

// props 타입을 선언한다.
interface SampleProps {
    required?: boolean
    text: string
}

// state 타입을 선언한다.
interface SampleState {
    count: number
    isLimited?: boolean
}

// Component에 제네릭으로 props, state를 순서대로 넣어준다.
class SampleComponent extends React.Component<SmapleProps, SampleState> {
    // contructor에서 props를 넘겨주고, state의 기본값을 설정한다.
    private constructor(props: SampleProps) {
        super(props)
        this.state = {
            count: 0,
            isLimited: false,
        }
    }
}

// render 내부에서 쓰일 함수를 선언한다.
private handleClick = () => {
    const newValue = this.state.count + 1
    this.setState(( count: newValue, isLimited: newValue >= 10))
}

// render에서 이 컴포넌트가 렌더링할 내용을 정의한다.
public render() {
    // props와 state 값을 this, 즉 해당 클래스에서 꺼낸다.
    const {
        props: {required, text},
        state: {count, isLimited},
    } = this

    return (
        <h2>
        Sample Component
        <div>문자: {text}</div>
        <div>count: {count}</div>
        <button onClick={this.handleClick} disabled={isLimited}>
        증가
        </button>
        </h2>
    )
}
```

위 예제의 코드를 부분별로 조금씩 자세히 살펴보자.

-   constructor(): 컴포넌트 내부에 이 생성자 함수가 있다면 컴포넌트가 초기화되는 시점에 호출된다. 여기서는 컴포넌트의 state를 초기화할 수 있다. 그리고 여기에 선언됑 있는 super()는 컴포넌트를 만들면서 상속받은 상위 컴포넌트, 즉 React.Component의 생성자 함수를 먼저 호출해 필요한 상위 컴포넌트에 접근할 수 있게 도와준다.

---

-   constructor가 없어도 state를 초기화할 수 있지 않나요?
    간혹 constructor를 쓰지 않고 초기화한 다음과 같은 코드를 본 적이 있을 것이다.

```javascript
import { Component } from "react";

class SampleComponent2 extends Component {
    state = {
        count: 1,
    };

    render() {
        const {
            state: { count },
        } = this;
        return <div>{count}</div>;
    }
}
```

이는 ES2022에 추가된 클래스 필드(class fields) 덕분에 가능한 문법이다. 이 문법은 별도의 초기화 과정을 거치지 않고도 클래스 내부에 필드를 선언할 수 있게 도와준다. 이 문법은 비교적 최신인 ES2022에서 등장했으므로 ES2022 환경을 지원하는 브라우저에서만 코드를 제공하거나 바벨의 @babel/plugin-class-properties를 사용해 트랜스파일을 거쳐야한다.

-   props: 함수에 인수를 넣는 것과 비슷하게, 컴포넌트에 특정 속성을 전달하는 용도로 쓰인다. 위 예제에서는 props가 { required?: boolean; text: string; } 형태로 선언해야 한다.
-   state: 클래스 컴포넌트 내부에서 관리하는 값을 의미한다. 이 값은 항상 객체여야만 한다. 이 값에 변화가 있을 때마다 리렌더링이 발생한다.
-   메서드: 렌더링 함수 내부에서 사용되는 함수이며, 보통 DOM에서 발생하는 이벤트와 함께 사용된다. 이를 만드는 방식은 크게 3가지로 나뉜다.

*   constructor에서 this 바인드를 하는 방법: 일반적인 함수로 메서드를 만든다면 this가 undefined로 나오는 현상을 겪게 될 것이다. 이러한 현상이 발생하는 이유는 생성자가 아닌 일반 함수로 호출하게 되면 Thisdp 전역 객체(strict 모드에서는 undefined)가 바인딩되기 때문이다. 따라서 함수에 bind를 활용해 강제로 this를 바인딩해야 한다.

다음 예제에서는 일반 함수로 선언한 대신 this 바인딩을 사용했다.

```javascript
import {Component} from 'react'

// 빈 props를 선언
type Props = Record<string, never>

interface State {
    count: number
}

class SampleComponent extends Component<Props, State> {
    private contructor(props: Props) {
        super(props)
        this.state = {
            count: 1,
        }
        // handleClick의 this를 현재 클래스로 바인딩한다.
        this.handleClick = this.handleClick.bind(this)
    }
    private handleClick() {
        this.setState((prev) => ({count: prev.count +1}))
    }

    public render() {
        const {
            state: {count},
        } = this
        return (
            <div>
            <button onClick={this.handleClick}>증가</button>
            {count}
        )
    }
}
```

-   화살표 함수를 쓰는 방법: 앞선 예제처럼 실행 시점이 아닌 작성 시점에 this가 상위 스코프로 결정되는 화살표 함수를 사용한다면 굳이 바인딩하지 않더라도 사용할 수 있다.
-   렌더링 함수 내부에서 함수를 새롭게 만들어 전달하는 방법: 다음과 같이 메서드 내부에서 새롭게 함수를 만들어서 전달하는 방법이다.

```javascript
<button onClick={() => this.handleClick()}>증가</button>
```

그러나 이 방법을 사용하게 되면 매번 렌더링이 일어날 때마다 새로운 함수를 생성해서 할당하게 되므로 최적화를 수행하기가 매우 어려워진다. 따라서 이 방법은 지양하는 것이 좋다.

### 클래스 컴포넌트의 생명주기 메서드

클래스 컴포넌트를 사용하면서 가장 자주 언급되는 것이 바로 생명주기(life cycle)다. 함수 컴포넌트가 대세가 되면서 많이 잊혀졌지만 여전히 클래스 컴포넌트의 많은 코드가 생명주기 메서드에 의존하고 있다.그리고 이 생명주기 메서드가 뇌리에 너무나 깊게 박힌 나머지 함수 컴포넌트에서도 생명주기를 구현하고자 시도하는 모습을 볼 수 있다. 클래스 컴포넌트의 생명주기에는 무엇이 있고, 또 어떤 용도로 쓰였는지 살펴보자.

참고로 리액트 17로 넘어오면서 unsafe, 즉 안전하지 않다고 선언된 메서드(리액트 팀에서 지원 중단시킨 메서드)에 대해서는 다루지 않는다.

먼저 생명주기 메서드가 실행되는 시점은 크게 3가지로 나눌 수 있다.

-   마운트(mount): 컴포넌트가 마운팅(생성)되는 시점
-   업데이트(update): 이미 생성된 컴포넌트의 내용이 변경(업데이트)되는 시점
-   언마운트(unmount): 컴포넌트가 더 이상 존재하지 않는 시점

이 세 가지 시점을 염두에 두고 각 생명주기 메서드를 살펴보자.

#### render()

render() 또한 생명주기 메서드 중 하나로, 리액트 클래스 컴포넌트의 유일한 필수 값으로 항상 쓰인다. 이미 이름에서도 알 수 있듯이 이 함수는 컴포넌트가 UI를 렌더링하기 위해서 쓰인다. 그리고 이 렌더링은 앞서 언급한 시점 중 두 가지인 마운트와 업데이트 과정에서 일어난다.

한 가지 주의할 것은 이 render() 함수는 항상 순수해야 하며 부수 효과가 없어야 한다는 것이다. 이 말인즉슨, 같은 입력값(props 또는 state)이 들어가면 항상 같은 결과물을 반환해야 한다는 뜻이다. 따라서 render() 내부에서 state를 직접 업데이트하는 this.setState를 호출해서는 안 된다. state를 변경하는 일은 클래스 컴포넌트의 메서드나 다른 생명주기 메서드 내부에서 발생해야 한다.

그러므로 이 함수는 항상 최대한 간결하고 깔끔하게 작성하는 것이 좋다. 그것이 이 함수 내의 부수 효과를 만들지 않고, 또 컴포넌트, 나아가 애플리케이션을 유지보수 가능하게끔 도와준다.

### componentDidMount()

클래스 컴포넌트가 마운트되고 준비가 됐다면 그다음으로 호출되는 생명주기 메서드가 바로 componentDidMount()다. 이 함수는 컴포넌트가 마운트되고 준비되는 즉시 실행된다. render()와는 다르게, 이 함수 내부에서는 this.setState()로 state 값을 변경하는 것이 가능하다. this.setState를 호출했다면 state가 변경되고, 그리고 그 즉시 다시 한번 렌더링을 시도하는데, 이 작업은 브라우저가 실제로 UI를 업데이트하기 전에 실행되어 사용자가 변경되는 것을 눈치챌 수 없게 만든다.

componentDidMount는 만능이 아니며 성능 문제를 일으킬 수 있음에 주의하자. 일반적으로 state를 다루는 것은 생성자에게 하는 것이 좋다. componentDidMount에서 this.setState를 허용하는 것은 생성자 함수에서는 할 수 없는 것. API 호출 후 업데이트, DOM에 의존적인 작업(이벤트 리스너 추가 등) 등을 하기 위해서다. 꼭 componentDidMount에서 할 수밖에 없는 작업인지 철저히 확인해 보고 사용하는 것이 좋다.

### componentDidUpdate()

componentDidUpdate()는 컴포넌트 업데이트가 일어난 이후 바로 실행된다. 일반적으로 state나 preps의 변화에 따라 DOM을 업데이트하는 등에 쓰인다. 여기서도 this.setState를 사용할 수 있다. 그러나 적절한 조건문으로 감싸지 않는다면 this.setState가 계속해서 호출되는 일이 발생할 수 있다. 이는 성능적으로 좋지 못하다.

```javascript
componentDidUpdate(prevProps: Props, prevState: State) {
    // 만약 이러한 조건문이 없다면 props가 변경되는 매 순간마다 fetchData가
    // 실행되는 불상사가 발생할 것이다.
    // 이 조건문은 덕분에 props의 userName이 이전과 다른 경우에만 호출될 것이다.
    if (this.props.userName !== prevProps.userName) {
        this.fetchData(this.props.userName)
    }
}
```

### componentWillUnmount()

이름에서 유추할 수 있듯이 이 생명주기 메서드는 컴포넌트가 언마운트되거나 더 이상 사용되지 않기 직전에 호출된다. 메모리 누수나 불필요한 작동을 막기 위한 클린업 함수를 호출하기 위한 최적의 위치다. 이 메서드 내에서는 this.setState를 호출할 수 없다.

```javascript
componentWillUnmount() {
    window.removeEventListener('resize', this.resizeListener)
    clearinterval(this.intervalid)
}
```

위 예제와 같이 이벤트를 지우거나, API 호출을 취소하거나, setInterval, setTimeout으로 생성된 타이머를 지우는 등의 작업을 하는 데 유용하다.

### shouldComponentUpdate()

state나 props의 변경으로 리액트 컴포넌트가 다시 리렌더링 되는 것을 막고 싶다면 이 생명주기 메서드를 사용하면 된다. 기본적으로 this.setState가 호출되면 컴포넌트는 리렌더링을 일으킨다. 그러나 이 생명주기 메서드를 활용하면 컴포넌트에 영향을 받지 않는 변화에 대해 정의할 수 있다.
