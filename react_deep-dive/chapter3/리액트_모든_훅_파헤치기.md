[배경]

함수 컴포넌트가 상태를 사용하거나 클래스 컴포넌트의 생명주기 메서드를 대체하는 등의 다양한 작업을 하기 위해 훅(hook)이라는 것이 추가됐다. 훅을 활용하면 클래스 컴포넌트가 아니더라도 리액트의 다양한 기능을 활용할 수 있다. 리액트에서 현재 사용 가능한 훅이 무엇이고, 어떻게 쓰이는지, 그리고 훅을 사용할 때 주의할 점은 무엇인지 확인해보자.

# 리액트의 모든 훅 파헤치기

리액트 함수 컴포넌트에서 가장 중요한 개념은 바로 훅이다. 혹은 클래스 컴포넌트에서만 가능했던 state, ref 등 리액트의 핵심적인 기능을 함수에서도 가능하게 만들었고, 무엇보다 클래스 컴포넌트보다 간결하게 작성할 수 있어 훅이 등장한 이래로 대부분의 리액트 컴포넌트는 함수 컴포넌트로 작성되고 있을 정도로 많은 사랑을 받고 있다.

## useState

리액트에서 훅을 언급할 때 가장 먼저 떠올리는 것이 바로 useState다. useState는 함수 컴포넌트 내부에서 상태를 정의하고, 이 상태를 관리할 수 있게 해주는 훅이다.

### useState 구현 살펴보기

먼저 useState 훅의 기본적인 사용법을 살펴보자.

```javascript
import { useState } from "react";

const [state, setState] = useState(initialState);
```

useState의 인수로는 사용할 state의 초깃값을 넘겨준다. 아무런 값을 넘겨주지 않으면 초깃값은 undefined다. useState 훅의 반환값은 배열이며, 배열의 첫 번째 원소로 state 값 자체를 사용할 수 있고, 두 번째 원소인 setState 함수를 사용해 해당 state의 값을 변경할 수 있다. 이제 이 훅이 어떻게 작동하는지 본격적으로 알아보자.

만약 useState를 사용하지 않고 함수 내부에서 자체적으로 변수를 사용해 상태값을 관리한다고 가정해 보자.

```javascript
function Component() {
    let state = 'hello'

     function handleButtonClick() {
        state = 'hi'
     }
}

return {
    <>
        <h1>{state}</h1>
        <button onClick={handleButtonClick}>hi</button>
    </>
}
```

위 코드가 동작하지 않은 이유는 무엇일까? 앞서 리액트에서 렌더링이 어떻게 일어나는지 살펴본 내용을 다시 한번 떠올려 보면 리액트에서 렌더링은 함수 컴포넌트의 return과 클래스 컴포넌트의 render 함수를 실행한 다음, 이 실행 결과를 이전의 리액트 트리와 비교해 리렌더링이 필요한 부분만 업데이트 해 이뤄진다고 정리했다. 그리고 리렌더링을 일으키는 방법에 대해서도 살펴봤는데, 위 코드에서는 리렌더링을 발생시키기 위한 조건을 전혀 충족하지 못하고 있다.

그렇다면 다음과 같이 하면 어떨까?

```javascript
function Component() {
    const [, triggerRender] = useState();
    let state = "hello";

    function handleButtonClick() {
        state = "hi";
        triggerRender();
    }

    return (
        <>
            <h1>{state}</h1>
            <button onClick={handleButtonClick}>hi</button>
        </>
    );
}
```

useState 반환값의 두 번째 원소를 실행해 리액트에서 렌더링이 일어나게끔 변경했다. 그럼에도 여전히 버튼 클릭 시 state의 변경된 값이 렌더링 되고 있지 않다. state가 업데이트되고 있는데 왜 렌더링이 되지 않을까? 그 이유는 리액트의 렌더링은 함수 컴포넌트에서 반환한 결과물인 return 의 값을 비교해 실행되기 때문이다. 즉, 매번 렌더링이 발생될 때마다 함수는 다시 새롭게 실행되고, 새롭게 실행되는 함수에서 state는 매번 hello로 초기화되므로 아무리 state를 변견해도 다시 hello로 초기화되는 것이다.

지금까지는 이해할 수 있는 과정으로 보인다. 함수 컴포넌트는 매번 함수를 실행해 렌더링이 일어나고, 함수 내부의 값은 함수가 실행될 때마다 다시 초기화된다. 그렇다면 useState 훅의 결괏값은 어떻게 함수가 실행되도 그 값을 유지하고 있을까?

리액트 내부 구현을 하나도 모른다고 가정하고 useState가 어떤 구조를 가지고 있을지 상상해 보자.

```javascript
function useState(initialValue) {
    let internalState = initialValue;

    function setState(newValue) {
        internalState = newValue;
    }

    return [internalState, setState];
}
```

그러나 이는 우리가 원하는 대로 작동하지 않는다.

```javascript
const [value, setValue] = useState(0);
setValue(1);
console.log(value); // 0
```

이러한 결과가 발생하는 이유는 setValue로 변경했음에도 이미 구조 분해 할당으로 state의 값, 즉 value를 이미 할당해 놓은 상태이기 때문에 훅 내부의 setState를 호출하더라도 변경된 새로운 값을 반환하지는 못한 것이다. 이를 해결하려면 먼저 state를 함수로 바꿔서 state의 값을 호출할 때마다 현재 state를 반환하게 하면 된다.

```javascript
function useState(initialValue) {
    let internalState = initialValue;

    function state() {
        return internalState;
    }

    function setState(newValue) {
        internalState = newValue;
    }

    return [state, setState];
}

const [value, setValue] = useState(0);
setValue(1);
console.log(value()); // 1
```

물론 이것은 우리가 사용하는 useState 훅의 모습과는 많이 동떨어져 있다. 우리는 state를 함수가 아닌 상수처럼 사용하고 있기 때문이다.

이를 해결하기 위해 리액트는 클로저를 이용했다. 여기서 클로저는 어떤 함수(useState) 내부에 선언된 함수가 함수의 실행이 종료된 이후에도(useState가 호출된 이후에도) 지역변수인 state를 계속 참조할 수 있다는 것을 의미한다.

그렇다면 실제로 useState는 어떤 형태로 구현돼 있을까? 다음 코드는 실제 리액트의 useState 코드가 아니라 작동 방식을 대략적으로 흉내 낸 코드다.

```javascript
const MyReact = (function () {
    const global = {};
    let index = 0;

    function useState(initialState) {
        if (!global.states) {
            // 애플리케이션 전체의 states 배열을 초기화한다.
            // 최초 접근이라면 빈 배열로 초기화한다.
            global.states = [];
        }

        // states 정보를 조회해서 현재 상태값이 있는지 확인하고,
        // 없다면 초기값으로 설정한다.
        const currentState = global.states[index] || initialState;
        // states의 값을 위에서 조회한 현재 값으로 업데이트 한다.
        global.states[index] = currentState;

        // 즉시 실행 함수로 setter를 만든다.
        const setState = (function () {
            // 현재 index를 클로저로 가둬놔서 이후에도 계속해서 동일한 index에
            // 접근할 수 있도록 한다.
            let currentIndex = index;
            return function (value) {
                global.states[currentIndex] = value;
                // 컴포넌트를 렌더링한다. 실제로 컴포넌트를 렌더링하는 코드는 생략했다.
            };
        })();
        // useState를 쓸 때마다 index를 하나씩 추가한다. 이 index는 setState에서 사용된다.
        // 즉, 하나의 state마다 index가 할당돼 있어 그 index가 배열의 값(global.states)을
        //가리키고 필요할 때마다 그 값을 가져오게 한다.
        index = index + 1;

        return [currentState, setState];
    }

    // 실제 useState를 사용하는 컴포넌트
    function Component() {
        const [value, setValue] = useState(0);
    }
})();
```

작동 자체만 구현했을 뿐, 실제 구현체와는 차이가 있다. 실제 리액트 코드에서는 useReducer를 이용해 구현돼 있다. useReducer와 useState는 크게 다르지 않은데, 이는 이후에 설명한다.

여기서 함수의 실행이 끝났음에도 함수가 선언된 환경을 기억할 수 있는 방법은 바로 1장에서 소개한 클로저다. 매번 실행되는 함수 컴포넌트 환경에서 state읙 값을 유지하고 사용하기 위해서 리액트는 클로저를 활용하고 있다. 예제의 경우 MyReact라고 불리는 클로저 내부에 useState와 관련된 정보를 저장해 두고, 이를 필요할 때마다 꺼내놓는 형식으로 구성돼 있다.

-   실제 리액트 내부에서 훅은 어떻게 구성돼어 있을까요?

*   이에 대한 정보를 알려면 리액트 깃허브 저장소를 참고해야 하는데, 훅에 대한 구현체를 타고 올라가다 보면 \_\_SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED라는 문구를 마주치게 된다.

*   이렇게 변수명을 무섭게 지능 이유는 일반 사용자의 접근을 차단하고, 나아가 실제 프로덕션 코드에서 사용하지 못하게 하기 위함으로 보인다. 실제로 여기에 접근하는 것을 리액트 팀에서도 권장하지 않는다. 이 변수에는 ReactSharedInternals라 불리는 내부 객체가 저장돼 있는 것으로 추정된다.

*   \_\_SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED는 리액트의 버전 관리 대상에서도 제외돼 있고, 앞서 언급한 것처럼 외부 사용자가 사용하거나 참고하는 것을 권장하지 않아 정확한 구현은 알기 어렵다. 대신 이번 장에서 훅에 대한 예제는 Preact의 구현을 기준으로 한다. Preact는 리액트의 경량화 버전으로, 대부분의 리액트 API를 지원학 있으며 리액트보다 가볍다는 장점이 있으며 무엇보다 모든 코드를 명확하게 볼 수 있다.

이렇듯 useState는 자바스크립트의 특징 중 하나인 클로저에 의존해 구현돼 있을 것이라는 사실을 짐작해 볼 수 있다. 클로저를 사용함으로써 외부에 해당 값을 노출시키지 않고 오직 리액트에서만 쓸 수 있어쏙, 함수 컴포넌트가 매번 실행되더라도 useState에서 이전의 값을 정확하게 꺼내 쓸 수 있게 됐다.

### 게으른 초기화

리액트에서는 렌더링이 실행될 떄마다 함수 컴포넌트의 함수가 다시 실행된다는 점을 명시하자. 함수 컴포넌트의 useState의 값 재실행된다. 물론 우리는 앞서 구현 예제를 통해 내부에는 클로저가 존재하며, 클로저를 통해 값을 가져오며 초깃값은 최초에만 사용된다는 것을 알고 있다. 만약 useState 인수로 자바스크립트에 많은 비용을 요구하는 작업이 들어가 있다면 이는 계속해서 실행될 위험이 존재할 것이다. 그러나 우리와는 다르게 useState 내부에 함수를 넣으면 이는 최초 렌더링 이후에는 실행되지 않고 최초의 state 값을 넣을 때만 실행된다.

만약 Number.parseInt(window.localStorage.getItem(cacheKey))와 같이 한 번 실행되는 데 어느 정도 비용이 드는 값이 있다고 가정해 보자. useState의 인수로 이 값 자체를 사용한다면 초깃값이 필요한 최초 렌더링과, 초깃값이 있어 더 이상 필요없는 렌더링 시에도 동일하게 게속 해당 값에 접근해서 낭비가 발생한다. 따라서 이런 경우에는 함수 형태로 인수에 넘겨주는 편이 훨씬 경제적일 것이다. 초기값이 없다면 함수를 핼행해 무거운 연산을 시도할 것이고, 이미 초깃값이 존재한다면 함수 실행을 하지 않고 기존 값을 사용할 것이다.

그렇다면 게으른 최적화는 언제 쓰는 것이 좋을까? 리액트에서는 무거운 연산이 요구될 때 사용하라고 한다. 즉, localStorage나 sessionStorage에 접근, map, filter, find 같은 배열에 대한 접근, 혹은 초깃값 계산을 위해 함수 호출이 필요할 때와 같이 무거운 연산을 포함해 실행 비용이 많이 드는 경우에 게으른 초기화를 사용하는 것이 좋다.

## useEffect

리액트 코드를 작성할 때 useState 만큼이나 자주 쓰는 훅이 바로 useEffect다. 대부분의 개발자에게 useEffect의 정의에 대해 물어본다면 다음과 같은 답변을 들을 수 있을 것이다.

-   useEffect는 두 개의 인수를 받는데, 첫 번째는 콜백, 두 번째는 의존성 배열이다. 이 두 번째 의존성 배열의 값이 변경되면 첫 번째 인수인 콜백을 실행한다.
-   클래스 컴포넌트의 생명주기 메서드와 비슷한 작동을 구현할 수 있다. 두 번째 의존성 배열에 빈 배열을 넣으면 컴포넌트가 마운트 될 때만 실행된다.
-   useEffect는 클린업 함수를 반환할 수 있는데, 이 클린업 함수는 컴포넌트가 언마운트될 때 실행된다.

이러한 useEffect에 대한 정의는 어느 정도 옳지만 완전히 정확하지는 않다. 그리고 useEffect는 자주 쓰지만 생각보다 사용하기 쉬운 훅이 아니다. 그리고 알려진 것처럼 생명주기 메서드를 대체하기 위해 만들어진 훅도 아니다.

useEffect의 정의를 정확하게 내리자면 useEffect는 애플리케이션 내 컴포넌트의 여러 값들을 활용해 동기적으로 부수 효과를 만드는 메커니즘이다. 그리고 이 부수 효과가 '언제' 일어나는지보다 어떤 상태값과 함께 실행되는지 살펴보는 것이 중요하다.

지금부터 그것이 무엇을 의미하는지, 또 어떤 식으로 작성하고 주의해야 하는지 살펴보자.

## UseEffect란?

먼저 useEffect의 일반적인 형태를 보자.

```javascript
function Component() {
    // ...
    useEffect(() => {
        // do Something
    }, [props, state]);
}
```

첫 번째 인수로는 실행할 부수 효과가 포함된 함수를, 두 번쨰 인수로는 의존성 배열을 전달한다. 이 의존성 배열은 어느 정도 길이를 가진 배열일 수도, 아무런 값이 없는 빈 배열일 수도 있고, 배열 자체를 넣지 않고 생략할 수도 있다. 각각의 차이점은 잠시 후에 소개한다.

의존성 배열이 변경될 때마다 useEffect의 첫 번째 인수인 콜백을 실행한다는 것은 널리 알려진 사실이다. 하지만 useEffect는 어떻게 의존성 배열이 변경된 것을 알고 실행될까? 여기서 한 가지 기억해야 할 사실은 바로 함수 컴포넌트는 매번 함수를 실행해 렌더링을 수행한다는 것이다.

다음 예제 코드를 살펴보자.

```javascript
function Component() {
    const [counter, setCounter] = useState(0);

    function handleClick() {
        setCounter((prev) => prev + 1);
    }

    return (
        <>
            <h1>{counter}</h1>
            <button onClick={handleClick}>+</button>
        </>
    );
}
```

버튼을 클릭하면 counter에 값을 1씩 올리는 평범한 컴포넌트다. 버튼을 클릭하면 이 함수 컴포넌트는 useState의 원리에 따라 다음과 같이 작동한다고 볼 수 있다.

```javascript
function Component() {
    const counter = 1;
    // ...
    return (
        <>
            <h1>{counter}</h1>
            <button onClick={handleClick}>+</button>
        </>
    );
}
```

즉, 함수 컴포넌트는 렌더링 시마다 고유의 state와 props 값을 갖고 있다. 여기에 useEffect가 추가된다면 다음과 같은 형태가 된다.

```javascript
function Component() {
    const counter = 1;

    useEffect(() => {
        console.log(counter); // 1, 2, 3, 4 ...
    });
    // ...
    return (
        <>
            <h1>{counter}</h1>
            <button inClick={handleClick}>+</button>
        </>
    );
}
```

useEffect는 자바스크립트의 proxy나 데이터 바인딩, 옵저버 같은 특별한 기능을 통해 값의 변화를 관찰하는 것이 아니고 렌더링할 때마다 의존성에 있는 값을 보면서 이 의존성의 값이 이전과 다른 게 하나라도 있으면 부수 효과를 실행하는 평범한 함수라고 볼 수 있다. 따라서 useEffect는 state와 props의 변화 속에서 일어나는 렌더링 과정에서 실행되는 부수 효과 함수라고 볼 수 있다.

## 클린업 함수의 목적

그렇다면 이른바 클린업 함수라 불리는 useEffect 내에서 반환되는 함수는 정확히 무엇이고 어떤 일을 할까? 일반적으로 이 클린업 함수는 이벤트를 등록하고 지울 때 사용해야 한다고 알려져 있다. 다음 예제를 살펴보자.
